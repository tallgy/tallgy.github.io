<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"tallgy.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.8.0","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="逐步学习">
<meta property="og:type" content="website">
<meta property="og:title" content="tallgy&#39;s blog">
<meta property="og:url" content="http://tallgy.gitee.io/index.html">
<meta property="og:site_name" content="tallgy&#39;s blog">
<meta property="og:description" content="逐步学习">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="tallgy">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://tallgy.gitee.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>tallgy's blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">tallgy's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="tallgy"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">tallgy</p>
  <div class="site-description" itemprop="description">逐步学习</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/tallgy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tallgy" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://gitee.com/tallgy" title="Gitee → https:&#x2F;&#x2F;gitee.com&#x2F;tallgy" rel="noopener" target="_blank"><i class="fab fa-github-alt fa-fw"></i>Gitee</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://tallgy.gitee.io/2021/10/31/%E9%9A%8F%E7%AC%94/Vue-methods%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="tallgy">
      <meta itemprop="description" content="逐步学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tallgy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/31/%E9%9A%8F%E7%AC%94/Vue-methods%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">Vue-methods使用箭头函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-31 16:51:55 / 修改时间：17:04:33" itemprop="dateCreated datePublished" datetime="2021-10-31T16:51:55+08:00">2021-10-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p>本篇随笔写的是在Vue的 <strong>methods</strong> 方法里面使用箭头函数。</p>
<p>在说明之前，我们先对这个进行一下分析：</p>
<p>首先 一个 <strong>Vue</strong> 的实例实则也是通过里面的对象进行的操作。</p>
<p>其次，<strong>箭头函数的作用</strong>，主要是 this 指向的不同，箭头函数的 this 指向是根据当前的上下文进行决定的。</p>
<p>所以首先可以认为，在Vue里面使用箭头函数，如果要使用 data里面 数据应该是不行，因为data里面的数据是通过 this 来获取，所以我们可以认为，Vue 内部对每个方法进行了一个this指向的变化，而箭头函数是无法修改的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var app4 = new Vue(&#123;</span><br><span class="line">  el: &#x27;#app-4&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; text: &#x27;学习 JavaScript&#x27;, flag: true &#125;,</span><br><span class="line">      &#123; text: &#x27;学习 Vue&#x27;, flag: false &#125;,</span><br><span class="line">      &#123; text: &#x27;整个牛项目&#x27;, flag: true &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    test() &#123;</span><br><span class="line">      console.log(this.todos);</span><br><span class="line">    &#125;,</span><br><span class="line">    test1: () =&gt; &#123;</span><br><span class="line">      console.log(this.todos);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p><strong>示例2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var a = 3;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  m: &#123;</span><br><span class="line">    t: () =&gt; &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">      console.log(this.a);</span><br><span class="line">    &#125;,</span><br><span class="line">    t1() &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">      console.log(this.a);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>t 使用的箭头函数，this 的指向为 window</p>
<p>t1 使用的普通函数，this 的指向，指向了调用他的方法。</p>
<p><strong>结论：</strong></p>
<ul>
<li>使用箭头函数的方法，确实不能获取到 data 的值</li>
<li>使用箭头函数后，this 的指向指向了 window 对象。</li>
<li>对于对象的对象的箭头函数，this的指向，还是指向的最外边的对象所处的上下文位置。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://tallgy.gitee.io/2021/10/30/%E9%9A%8F%E7%AC%94/HTML-%E6%A0%87%E7%AD%BE%E7%9A%84title/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="tallgy">
      <meta itemprop="description" content="逐步学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tallgy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/30/%E9%9A%8F%E7%AC%94/HTML-%E6%A0%87%E7%AD%BE%E7%9A%84title/" class="post-title-link" itemprop="url">HTML-标签的title</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-30 22:35:32" itemprop="dateCreated datePublished" datetime="2021-10-30T22:35:32+08:00">2021-10-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-31 18:34:05" itemprop="dateModified" datetime="2021-10-31T18:34:05+08:00">2021-10-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HTML-标签的title"><a href="#HTML-标签的title" class="headerlink" title="HTML-标签的title"></a>HTML-标签的title</h1><p>在学习的时候发现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span title=&quot;停滞的span&quot;&gt;显示的span&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<img src="/2021/10/30/%E9%9A%8F%E7%AC%94/HTML-%E6%A0%87%E7%AD%BE%E7%9A%84title/image-20211030223916508.png" alt="image-20211030223916508" style="zoom: 67%;">

<p>在页面上，鼠标进行放置可以显示 title，这个是一个html的title的特点。我们可以尝试对很多标签设置title，可以看看是否有效果。</p>
<h2 id="title"><a href="#title" class="headerlink" title="title"></a>title</h2><p>对一个标签添加 <strong>title</strong> 就可以实现。</p>
<h2 id="出现方式"><a href="#出现方式" class="headerlink" title="出现方式"></a>出现方式</h2><p>在一个标签的范围内，进行移动，超过了一定的时间就会显示。</p>
<h2 id="对于嵌套"><a href="#对于嵌套" class="headerlink" title="对于嵌套"></a>对于嵌套</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;height: 200px; border: 1px red solid;&quot; title=&quot;div&quot;&gt;</span><br><span class="line">  &lt;span title=&quot;停滞的span&quot;&gt;显示的span&lt;/span&gt;</span><br><span class="line">&lt;/div&gt; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在外面的会显示的是div，在span内部的会显示span，这个就像极了，在冒泡阶段进行stop。</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://tallgy.gitee.io/2021/10/29/JavaScript/JavaScript-%E5%86%92%E6%B3%A1%E5%92%8C%E6%8D%95%E8%8E%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="tallgy">
      <meta itemprop="description" content="逐步学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tallgy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/29/JavaScript/JavaScript-%E5%86%92%E6%B3%A1%E5%92%8C%E6%8D%95%E8%8E%B7/" class="post-title-link" itemprop="url">JavaScript-冒泡和捕获</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-29 10:54:26 / 修改时间：22:21:44" itemprop="dateCreated datePublished" datetime="2021-10-29T10:54:26+08:00">2021-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p> <strong>前言:</strong></p>
<h4 id="JavaScript-DOM的监听方式"><a href="#JavaScript-DOM的监听方式" class="headerlink" title="JavaScript-DOM的监听方式"></a><strong>JavaScript-DOM的监听方式</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dom.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">  console.log(&#x27;father1 捕获&#x27;);</span><br><span class="line">&#125;, true);</span><br><span class="line"></span><br><span class="line">dom.onclick = function (e) &#123;</span><br><span class="line">  console.log(&#x27;a2 冒泡&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里,又被称为 <strong>DOM0级</strong> 和 <strong>DOM2级</strong></p>
<p><strong>0级DOM</strong>:</p>
<ul>
<li>标签内部的 onclick 事件</li>
<li>JavaScript 的 onclick = function() {} 函数</li>
</ul>
<p><strong>2级DOM:</strong></p>
<ul>
<li>就是标准的事件模型</li>
<li><strong>addEventListener</strong> 和 <strong>removeEventListener</strong></li>
</ul>
<h1 id="JavaScript-冒泡和捕获"><a href="#JavaScript-冒泡和捕获" class="headerlink" title="JavaScript-冒泡和捕获"></a>JavaScript-冒泡和捕获</h1><p>参考文章，感觉写的很详细</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/sinat_33523805/article/details/94018242</span><br></pre></td></tr></table></figure>

<p>​        在一个 <code>Event</code> 的事件中，存在三个阶段：<code>捕获，目标和冒泡</code></p>
<p><strong>三个阶段的顺序：</strong></p>
<ul>
<li><p>首先是从根节点出发，到达目标节点，若此过程中触发了事件，则被称为<strong>捕获阶段</strong></p>
</li>
<li><p>然后当节点到达定义点击事件的目标节点时，处于<strong>目标阶段</strong></p>
</li>
<li><p>在目标节点触发事件后，最后就会一路往上回到根节点，处于 <strong>冒泡阶段</strong></p>
<p>​    给一张对应的图片。</p>
</li>
</ul>
<img src="/2021/10/29/JavaScript/JavaScript-%E5%86%92%E6%B3%A1%E5%92%8C%E6%8D%95%E8%8E%B7/image-20210907141230550.png" alt="image-20210907141230550" style="zoom:67%;">

<p>​        如何在创建一个点击监听的时候，同时定义是处于冒泡还是捕获阶段。</p>
<p>​        通过一个 <code>addEventListener</code> 函数的参数，分别为 <strong>事件名， 回调函数， 在什么阶段执行</strong>。第三个参数就是判断是处于什么阶段的。<strong>true代表捕获阶段，false代表了冒泡阶段</strong>。</p>
<p>​        对于target，顺序不是按照捕获和冒泡的顺序，而是按照监听函数的创建顺序。</p>
<p>​        可以通过 <code>event.eventPhase</code> 的值来判断是处于哪个阶段。</p>
<p>​            <code>1，捕获阶段。2，目标阶段。3，冒泡阶段</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">father.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">  console.log(&#x27;father 捕获&#x27;);</span><br><span class="line">  console.log(e.eventPhase);	// 1</span><br><span class="line">&#125;, true);</span><br><span class="line">father.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">  console.log(&#x27;father 冒泡&#x27;);</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">children.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">  console.log(&#x27;children 冒泡&#x27;);</span><br><span class="line">&#125;, false);</span><br><span class="line">children.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">  console.log(&#x27;children 捕获&#x27;);</span><br><span class="line">&#125;, true);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">father 捕获</span><br><span class="line">children 冒泡</span><br><span class="line">children 捕获</span><br><span class="line">father 冒泡</span><br></pre></td></tr></table></figure>



<p><strong>结论：</strong></p>
<ul>
<li><p>捕获是从根到target， 冒泡是从target到根。</p>
</li>
<li><p>先捕获，后冒泡。</p>
</li>
<li><p>可以通过 <code>addEventListener</code> 的第三个参数来决定这个监听处于捕获还是处于冒泡。默认是冒泡阶段。</p>
</li>
<li><p>对于 <code>target</code> 元素，没有捕获冒泡一说，先定义先执行。</p>
</li>
<li><p>可以通过 <code>event.eventPhase</code> 来判断当前处于什么阶段。</p>
</li>
</ul>
<h1 id="取消事件传递"><a href="#取消事件传递" class="headerlink" title="取消事件传递"></a>取消事件传递</h1><p>​        通过这三个方式 <code>stopPropagation()</code> 、<code>prenventDefault()</code>、<code>return false;</code>、<code>stopImmediatePropagation()</code>。</p>
<ul>
<li><p><code>stopPropagation()</code> </p>
<ul>
<li>会停止事件的传递。但是不会阻止事件的默认方法。</li>
</ul>
</li>
<li><p><code>stopImmediatIePropagation()</code> </p>
<ul>
<li>同上，但是对于多个相同的事件都会被阻止。具体区别一会儿看案例.</li>
</ul>
</li>
<li><p><code>prenventDefault()</code> </p>
<ul>
<li>取消掉元素的默认行为.</li>
</ul>
</li>
<li><p><code>return false;</code> </p>
<ul>
<li>会取消默认行为,但是只能用于 DOM0级.</li>
<li>但是不会终止事件的传递.</li>
</ul>
</li>
</ul>
<h2 id="stopPropagation-和-stopImmediatIePropagation-的使用"><a href="#stopPropagation-和-stopImmediatIePropagation-的使用" class="headerlink" title="stopPropagation 和 stopImmediatIePropagation 的使用"></a>stopPropagation 和 stopImmediatIePropagation 的使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">children1.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">	console.log(&#x27;a 捕获&#x27;);</span><br><span class="line">	e.stopPropagation();</span><br><span class="line">&#125;, true);	//为true,代表了捕获.</span><br><span class="line">  </span><br><span class="line">children1.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">    console.log(&#x27;a1 捕获&#x27;);</span><br><span class="line">&#125;, true);	//为true,代表了捕获.</span><br><span class="line"></span><br><span class="line">这里对上面进行了 stopPropagation 所以会停止传递,但是</span><br><span class="line">	对于上层元素,传递会直接停止,所以如果是在捕获层进行了使用,那么就会在调用了本层方法后,就会停止, 如果是在冒泡层进行使用,就会结束后续的冒泡行为.</span><br><span class="line">	对于 target 的使用,因为 target 不分冒泡和捕获,所以两个都会执行.</span><br><span class="line">执行结果:	father 捕获, target 捕获, target 冒泡(阻止了事件的继续.虽然这个阻止放在了 捕获 位置, 但是对于 target 是不分 冒泡 和 捕获 的.所以 target 的冒泡也会执行.)</span><br><span class="line">	其中对于 target 的捕获和冒泡的顺序,按照定义的顺序执行.</span><br><span class="line"></span><br><span class="line">对于 stopImmediatIePropagation 的使用,大体上和上面起始差不多,最大的区别就是,不但会停止传递,并且会停止本层的相同事件.</span><br><span class="line">比如代码类型:</span><br><span class="line"></span><br><span class="line">    children1.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">        console.log(&#x27;a 捕获&#x27;);</span><br><span class="line">    	e.stopImmediatePropagation();</span><br><span class="line">    &#125;, true);</span><br><span class="line">    children1.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">        console.log(&#x27;a1 捕获&#x27;);</span><br><span class="line">    &#125;, true);</span><br><span class="line">    children1.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">        console.log(&#x27;a 冒泡&#x27;);</span><br><span class="line">    &#125;, false);</span><br><span class="line">	</span><br><span class="line">	我这里定义了两个相同的捕获. 但是使用的是 e.stopImmediatePropagation(); 所以,对于相同的事件都会停止,然后因为这个 stopImmediatePropagation 放在了最上面定义的位置,所以放在下面的都不会执行. 如果我把这个函数的位置放在了第二个,那么第一个还是会执行</span><br><span class="line">执行结果:</span><br><span class="line">	father 捕获, target 捕获(阻止了事件的传递. 并且因为target的捕获和冒泡属于同一类型,所以都被阻止了.)</span><br></pre></td></tr></table></figure>

<p><strong>简单总结:</strong></p>
<ul>
<li><strong>stopPropagation</strong><ul>
<li>对于非target, 会阻止后续的事件, 但是对于相同的事件不会阻止.</li>
<li>对于 target, 因为 target 是<strong>不分冒泡和捕获</strong>,所以只会阻止上级元素的事件,对于 target 的<strong>冒泡</strong> 和 <strong>捕获</strong> 都不会阻止.</li>
</ul>
</li>
<li><strong>stopImmediatIePropagation</strong><ul>
<li>这个不但会阻止后续的事件, 对于相同的事件也会阻止.</li>
</ul>
</li>
<li><strong>相同点</strong>是: 他们都<strong>不会阻止元素的默认事件的执行,就算是捕获和冒泡没有到target.</strong></li>
</ul>
<h2 id="prenventDefault-使用"><a href="#prenventDefault-使用" class="headerlink" title="prenventDefault 使用"></a>prenventDefault 使用</h2><p><strong>作用:</strong></p>
<p>​    取消元素的默认行为.如果放在了父元素,那么子元素的所有默认行为都会被取消.</p>
<p><strong>使用方式:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  children1.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">    console.log(&#x27;a 捕获&#x27;);</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125;, true);</span><br><span class="line">  </span><br><span class="line">这个很简单.</span><br></pre></td></tr></table></figure>



<h2 id="return-false-的使用"><a href="#return-false-的使用" class="headerlink" title="return false; 的使用"></a>return false; 的使用</h2><p>这个的使用方式不和上面的一样.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  children1.onclick = function (e) &#123;</span><br><span class="line">    console.log(&#x27;a2 冒泡&#x27;);</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">不能在 addEventListener 的回调函数里面使用. 因为这个是通过return 的值为false,来进行的定义,如果要使用 addEventListener 的回调的话, 函数的返回值不能正确返回,但是要怎么实现我也不知道.</span><br></pre></td></tr></table></figure>



<h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><p>​        理解很简单, 就是子元素的点击, 父级也可以进行捕获和冒泡, 很多人说事件委托是利用的冒泡原理, 但是通过前面的学习我们可以知道,事件委托,无非就是 子元素 的点击可以被父元素所监听到. 所以这里肯定会感觉不对, 然后我去网上看了一篇文章,  然后断章取义了一番.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/mmrsdym/article/details/39209375</span><br></pre></td></tr></table></figure>

<p>​        我了解到了,为什么事件委托要使用的是冒泡原理, 而不是使用的捕获的原因.</p>
<p>​        大概的意思就是, 一个元素是先进行的捕获行为, 然后再进行的冒泡行为. 所以如果我们将事件委托放在了, 捕获上面. 如果要阻止事件的行为, 那么就会让子元素的所有事件都不能执行, 而放在了事件的冒泡的话, 子元素的一些行为还是可以执行的.  所以这就是为什么事件委托需要放在冒泡的原因. </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://tallgy.gitee.io/2021/10/27/CSS/CSS-flex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="tallgy">
      <meta itemprop="description" content="逐步学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tallgy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/27/CSS/CSS-flex/" class="post-title-link" itemprop="url">CSS-flex</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-27 15:54:35" itemprop="dateCreated datePublished" datetime="2021-10-27T15:54:35+08:00">2021-10-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-29 10:52:09" itemprop="dateModified" datetime="2021-10-29T10:52:09+08:00">2021-10-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSS/" itemprop="url" rel="index"><span itemprop="name">CSS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="CSS-flex布局"><a href="#CSS-flex布局" class="headerlink" title="CSS-flex布局"></a>CSS-flex布局</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox</span><br></pre></td></tr></table></figure>

<p>​        flex就是弹性布局。</p>
<p>​        基本使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display: flex;</span><br></pre></td></tr></table></figure>



<h2 id="主轴"><a href="#主轴" class="headerlink" title="主轴"></a>主轴</h2><p>​        <code>flex-direction</code> 定义主轴</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">row，row-reverse</span><br><span class="line">代表inline，横向延申</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">column，column-reverse</span><br><span class="line">代表black，竖向排列</span><br></pre></td></tr></table></figure>

<p>​        其中 <code>reverse </code>代表翻转，就是反过来的排列顺序</p>
<h2 id="交叉轴，副轴"><a href="#交叉轴，副轴" class="headerlink" title="交叉轴，副轴"></a>交叉轴，副轴</h2><p>​        就是和主轴垂直的轴</p>
<p>​        如果主轴是横轴，那么交叉轴就是数轴。</p>
<h1 id="当使用了-Flex容器"><a href="#当使用了-Flex容器" class="headerlink" title="当使用了 Flex容器"></a>当使用了 Flex容器</h1><p>​        在定义了 <code>display: flex;</code> 之后的一些默认行为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">元素排列一行，(因为 flex-direction 的默认值是 row )</span><br><span class="line">从主轴的起始线开始，这里起始线一般就是如果是row，代表了从左向右，其他的	情况查看MDN文档</span><br><span class="line">元素不会再主维度拉伸，但是可以缩小</span><br><span class="line">元素被拉伸来填充交叉轴大小</span><br><span class="line">flex-basis 为 auto</span><br><span class="line">flex-wrap 为 nowrap</span><br></pre></td></tr></table></figure>



<h1 id="对于flex属性值的行为"><a href="#对于flex属性值的行为" class="headerlink" title="对于flex属性值的行为"></a>对于flex属性值的行为</h1><h2 id="flex-direction-设置主轴"><a href="#flex-direction-设置主轴" class="headerlink" title="flex-direction 设置主轴"></a>flex-direction 设置主轴</h2><p>​        对定义了 <code>display: flex;</code> 的元素使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">flex-direction</span><br><span class="line">	row</span><br><span class="line">		横向，从左到右</span><br><span class="line">	row-reverse</span><br><span class="line">		横向，从右到左</span><br><span class="line">		对于行内块元素和话，宽度的计算是和 Colum-reverse 类似的。</span><br><span class="line">	column</span><br><span class="line">		纵向，从上到下</span><br><span class="line">	column-reverse</span><br><span class="line">		纵向，从下到上</span><br><span class="line">		对于没有设置高度的，就会按照最小高度进行计算，(意思就是说，高度和column的一样，只是方向反了而已。)</span><br></pre></td></tr></table></figure>



<h2 id="flex-wrap-实现多行flex"><a href="#flex-wrap-实现多行flex" class="headerlink" title="flex-wrap 实现多行flex"></a>flex-wrap 实现多行flex</h2><p>​        对定义了 <code>display: flex;</code> 的元素使用</p>
<p>​        在这样做的时候，您应该把每一行看作一个新的<code>flex</code>容器。 任何空间分布都将在该行上发生，而不影响该空间分布的其他行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wrap</span><br><span class="line">	会换行，而不是进行缩小</span><br><span class="line">nowrap</span><br><span class="line">	不会换行，会使用缩小的规则进行缩小，对于不能缩小的，会导致溢出。</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>如果在使用 wrap 时，使用了 flex:1， 时，这个时候就需要注意要不要定义 flex-basis 了。</li>
</ul>
<p>​            <strong>原因</strong>： 因为 <code>flex: 1</code>; 对应了 <code>flex-grow: 1</code> &amp; <code>flex-shrink: 1</code> &amp;&amp; <code>flex-basis: 0</code>  ，所以其实原因就是 flex-basis 为 0 了。所以如果不自己定义一个 flex-basis 的话，就不会进行换行。</p>
<ul>
<li><p>还有就是，对于每一个换行之后的元素，每一行都算是一个弹性行，所以对于以下代码</p>
<ul>
<li>```<br>flex: 1 1 160px;子元素在160px，换行之后，会对每一行的每个元素进行 扩张 和 收缩 的重新计算。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  参考 MDN 链接：</span><br><span class="line">  https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Mastering_Wrapping_of_Flex_Items</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="简写属性-flex-flow"><a href="#简写属性-flex-flow" class="headerlink" title="简写属性 flex-flow"></a>简写属性 flex-flow</h2><p>​        对定义了 <code>display: flex;</code> 的元素使用</p>
<p>​        是 <code>flex-direction</code> 和 <code>flex-wrap</code> 的组合</p>
<p>​        对于没有写的，就会使用默认值：row 和 nowrap</p>
<p><strong>注：</strong></p>
<ul>
<li>从谷歌浏览器的显示来说:<ul>
<li>如果设置 <code>flex-flow: column; </code>  ，就直接代表了 <code>flex-direction: column;</code> ，而不会定义 <code>flex-wrap</code></li>
<li>如果设置 <code>flex-flow: wrap; </code>  ，就代表了 <code>flex-direction: initial;</code> 而  <code>flex-flow: wrap; </code> </li>
</ul>
</li>
</ul>
<h2 id="flex-basis-元素的空间大小"><a href="#flex-basis-元素的空间大小" class="headerlink" title="flex-basis 元素的空间大小"></a>flex-basis 元素的空间大小</h2><p>​        该属性的默认值是 <code>auto</code> ，此时，浏览器会检查这个元素是否具有确定的尺寸(width / heght ，这个看是使用 row 还是 Colum)，如果<strong>具有确定的尺寸</strong>，就会将该值设置为 flex-basis。如果没有设定尺寸，就会采用<strong>元素内容的尺寸</strong>。如果不使用  <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing"><code>box-sizing</code></a> 改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的尺寸。</p>
<h2 id="flex-grow-延展比例"><a href="#flex-grow-延展比例" class="headerlink" title="flex-grow 延展比例"></a>flex-grow 延展比例</h2><p>​        负值无效，默认为0</p>
<p>​        简单来说，这个是一个比例，对于存在可用空间的(可用空间：就是指在使用之后，父元素还存在剩余的空间。)， 子元素会根据这个比例将可用空间占据。</p>
<p>​        比如：两个子元素，一个为 1， 一个为 2，父元素的可用空间为 90，那么第一个就会扩张 1/(1+2) * 90 ， 第二个就会扩张 2/(1+2) * 90 。</p>
<h2 id="flex-shrink-收缩比例"><a href="#flex-shrink-收缩比例" class="headerlink" title="flex-shrink 收缩比例"></a>flex-shrink 收缩比例</h2><p>​        负值无效，默认为1</p>
<p>​        简单来说，就会对于如果容器不够排列 flex元素的空间。那么就会按照比例进行收缩。默认为1</p>
<p>​        计算方式： 这里的计算方式略和 <code>flex-grow</code> 有所不同。他的计算会和 <code>flex-basis</code> 相关联。这里给出计算的方法</p>
<p>​            每个元素的 <code>flex-basis</code> * <code>flex-shrink</code> 这个值作为一个比例<strong>X1</strong>，将所有参与计算的元素进行计算 <strong>X1~Xi 的求和 Xs</strong> ，然后再计算出超出的量，这个超出的量是 <strong>overflow = 子元素的flex-basis 的总和 - 父元素的宽度</strong>， 然后就是进行计算 <strong>Xi / Xs * overflow</strong>， 这个计算出的值就是需要减去的量，这里可能有点抽象，我们也给一个例子方便理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">div	width:600px</span><br><span class="line">	div flex: 1 1 200px;</span><br><span class="line">	div flex: 1 1 200px;</span><br><span class="line">	div flex: 1 2 300px;</span><br><span class="line"></span><br><span class="line">首先我们可以看出，这个是超出了，所以需要收缩，</span><br><span class="line">超出的量 overflow = 600 - 200 - 200 - 300 = 100px</span><br><span class="line">然后比例的计算</span><br><span class="line">	X1 = 1 * 200 = 200px</span><br><span class="line">	X2 = 1 * 200 = 200px</span><br><span class="line">	X3 = 2 * 300 = 600px</span><br><span class="line">所以 Xs = X1 + X2 + X3 = 1000px</span><br><span class="line">然后就是计算收缩的值	Xi / Xs * overflow</span><br><span class="line">	200 / 1000 * 100 = 20</span><br><span class="line">	200 / 1000 * 100 = 20</span><br><span class="line">	600 / 1000 * 100 = 60</span><br><span class="line">	</span><br><span class="line">所以最终的宽度是</span><br><span class="line">div width: 600px</span><br><span class="line">	div width: 180px</span><br><span class="line">	div width: 180px</span><br><span class="line">	div width: 240px</span><br></pre></td></tr></table></figure>

<p>在这里我也看到了一个更详细的一些计算教程，虽然里面的内容是否正确我没有进行参考，但是写的很详细，我就把链接贴出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/liyan-web/p/11217330.html</span><br></pre></td></tr></table></figure>

<p>​    <strong>注意点：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Controlling_Ratios_of_Flex_Items_Along_the_Main_Ax</span><br></pre></td></tr></table></figure>

<p>​        这个元素在缩小的时候，不会小于最小宽度，至于这个最小宽度定义，我现在认为就是可以造成溢出的情况。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">	222222222222222222222222222222222222</span><br><span class="line">	</span><br><span class="line">	在这个情况，如果这个div想对于父元素的弹性布局，造成了溢出，但是因为最小的宽度为这个文字的一个长度，不会换行，所以会造成溢出。</span><br><span class="line">	而 22222 222222 222222222 222222 2222，这里，因为在 文字里面加入了空格，在html文档里面一个最小宽度是一个空格隔开的一个距离，所以会出现换行而不会让宽度溢出的情况。</span><br><span class="line">	这里记录一下会统计最小宽度的情况。</span><br><span class="line">		&#x27; &#x27;(不能使用 &amp;nbsp; ), &#x27;。&#x27;(。会在上一行), &#x27;，&#x27;(中文，号)，这里的原因应该是中文的。和， 里面的一个字符形势和 . ,不一样。</span><br><span class="line">	注意：只能是 英文和数字，中文会自动换行。原因应该是 对于英文，如果不打空格，浏览器会认为是一个单词，所以不会换行。</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><code>flex-grow</code> &amp;&amp; <code>flex-shrink</code> 的值要为正数。</li>
</ul>
<h2 id="简写属性-flex"><a href="#简写属性-flex" class="headerlink" title="简写属性 flex"></a>简写属性 flex</h2><p>​        对弹性布局的子元素使用。</p>
<p>​        包含了： <code>flex-grow</code>  、 <code>flex-shrink</code> 和 <code>flex-basis</code> </p>
<p>​        对于每个属性的值，都有理解了。我们就说几个简写的代表意思</p>
<ul>
<li><code>flex: initial</code><ul>
<li>代表初始值：<code>flex: 0 1 auto</code></li>
</ul>
</li>
<li><code>flex: auto</code><ul>
<li>代表 <code>flex: 1 1 auto</code></li>
</ul>
</li>
<li><code>flex: none</code><ul>
<li>代表 <code>flex: 0 0 auto</code></li>
</ul>
</li>
<li><code>flex: &lt;positive-number&gt;</code><ul>
<li>代表 <code>flex: x x 0</code></li>
</ul>
</li>
</ul>
<h2 id="align-items-交叉轴方向对齐"><a href="#align-items-交叉轴方向对齐" class="headerlink" title="align-items 交叉轴方向对齐"></a>align-items 交叉轴方向对齐</h2><p>​        默认为 <code>stretch </code>，默认会被拉伸到最高元素的高度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stretch</span><br><span class="line">	拉伸到最高元素的高度</span><br><span class="line">flex-start</span><br><span class="line">	按flex容器的顶部对齐</span><br><span class="line">flex-end</span><br><span class="line">	按flex容器的下部对齐</span><br><span class="line">center</span><br><span class="line">	使它们居中对齐</span><br></pre></td></tr></table></figure>



<h2 id="justify-content-主轴方向对齐"><a href="#justify-content-主轴方向对齐" class="headerlink" title="justify-content 主轴方向对齐"></a>justify-content 主轴方向对齐</h2><p>​        初始值是 <code>flex-start</code>， 元素从容器的起始线排列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stretch</span><br><span class="line">	不了解</span><br><span class="line">flex-start</span><br><span class="line">	从容器的起始线排列</span><br><span class="line">flex-end</span><br><span class="line">	从容器的终止线开始排列</span><br><span class="line">center</span><br><span class="line">	在中间排列</span><br><span class="line">space-around</span><br><span class="line">	把元素排列好之后的剩余空间拿出来，平均分配到元素之间，所以元素之间间隔相等</span><br><span class="line">space-between</span><br><span class="line">	使每个元素的左右空间相等</span><br></pre></td></tr></table></figure>



<h1 id="对于flex的溢出："><a href="#对于flex的溢出：" class="headerlink" title="对于flex的溢出："></a>对于flex的溢出：</h1><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对一个元素设置了flex布局，其中的子元素的子元素的宽度可以造成溢出</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.father</span><br><span class="line">	div.children</span><br><span class="line">	</span><br><span class="line">father 元素设置了弹性布局， children 元素只设置一个宽度，会发现 children 的宽度不会高于father的宽度。主要是因为涉及了</span><br></pre></td></tr></table></figure>

<img src="/2021/10/27/CSS/CSS-flex/image-20211027210947232.png" alt="image-20211027210947232" style="zoom: 50%;">



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">但是</span><br><span class="line">div.father</span><br><span class="line">	div.children</span><br><span class="line">		div.cChildren</span><br><span class="line"></span><br><span class="line">这个对于 cChildren 的宽度就会将 children 的宽度顶出来，造成溢出。</span><br><span class="line">其中，这里的宽度，如果 cChildren 大于了 father 就会将 cChildren 和 children 顶出来。</span><br><span class="line">但是如果 cChildren 大于了 children 的话，就会再 children 到达他所定义的宽度之后，就不会继续扩张了。</span><br></pre></td></tr></table></figure>

<img src="/2021/10/27/CSS/CSS-flex/image-20211027211015004.png" alt="image-20211027211015004" style="zoom:50%;">



<img src="/2021/10/27/CSS/CSS-flex/image-20211027212431340.png" alt="image-20211027211015004" style="zoom:50%;">



<p>​        但是这里的计算方式我没有理解到为什么。</p>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>​        设置 <code>flex-shrink: 0;</code> 属性，因为设置了0之后代表了不会对超过的部分进行处理。</p>
<h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><p>​        这个是文字超出导致的溢出，就是如果文字，或者 img图片的设置超过了宽高也会造成溢出。</p>
<p>​        这个的原因是因为，对于英文和数字，浏览器不能识别你的单词是否是一个，所以如果你输入一串英文和数字，中间没有分割(前面有说)，就会造成溢出，而汉字不行。</p>
<img src="/2021/10/27/CSS/CSS-flex/image-20211027213217557.png" alt="image-20211027213217557" style="zoom:50%;">



<h3 id="方式四"><a href="#方式四" class="headerlink" title="方式四"></a>方式四</h3><p>​        我们可以发现，flex 对于溢出的处理，默认只是针对于主轴，所以对于侧轴是没有溢出处理的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.father &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    width: 50px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.children &#123;</span><br><span class="line">	width: 60px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/10/27/CSS/CSS-flex/image-20211027214029980.png" alt="image-20211027214029980" style="zoom:50%;">




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://tallgy.gitee.io/2021/10/25/CSS/CSS-%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="tallgy">
      <meta itemprop="description" content="逐步学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tallgy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/25/CSS/CSS-%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8/" class="post-title-link" itemprop="url">CSS-元素选择器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-25 19:51:58" itemprop="dateCreated datePublished" datetime="2021-10-25T19:51:58+08:00">2021-10-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-26 15:31:59" itemprop="dateModified" datetime="2021-10-26T15:31:59+08:00">2021-10-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSS/" itemprop="url" rel="index"><span itemprop="name">CSS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="CSS-元素选择器"><a href="#CSS-元素选择器" class="headerlink" title="CSS-元素选择器"></a>CSS-元素选择器</h1><h2 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Adjacent_sibling_combinator</span><br></pre></td></tr></table></figure>

<p>​        <strong>相邻兄弟选择器</strong> (<code>+</code>) 介于两个选择器之间，当第二个元素<em>紧跟在</em>第一个元素之后，并且两个元素都是属于同一个父<code>元素</code>的子元素，则第二个元素将被选中。</p>
<p><strong>注：</strong></p>
<p>​    第一，要相邻之后的，不相邻的，在前面的不管。 </p>
<p>​    只会选择一个，就算第二个元素有多个满足，只会选择最开始的一个。</p>
<p>​    但是对于第一个元素就可以有很多个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.f + .b &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors</span><br></pre></td></tr></table></figure>

<p>​        CSS <strong>属性选择器</strong>通过已经存在的属性名或属性值匹配元素。</p>
<p>选择存在这个属性的元素，这个属性不一定要含有意义，也不一定有值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div[cc] &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">存在cc，但是cc是一个没有意义的属性，也可以被选中。</span><br><span class="line">&lt;div class=&quot;b&quot; cc&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<h3 id="属性选择器值的匹配"><a href="#属性选择器值的匹配" class="headerlink" title="属性选择器值的匹配"></a>属性选择器值的匹配</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存在属性cc，并且值为xxx</span><br><span class="line">[cc=&#x27;xxx&#x27;]</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;b&quot; cc=&quot;xxx&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存在属性cc，并且值包含了xx</span><br><span class="line">cc *= &#x27;xx&#x27;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;b&quot; cc=&quot;111xxasf&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存在属性cc，并且该属性是一个以空格作为分隔的值列表，其中至少有一个值为 xx。</span><br><span class="line">cc ~= &#x27;xx&#x27;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;b&quot; cc=&quot;111 xx asf&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存在属性cc，并且属性值为“xx”或是以“xx-”为前缀</span><br><span class="line">cc |= &#x27;xx&#x27;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;b&quot; cc=&quot;xx-asf&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存在属性cc，并且属性值是以 xx 开头的元素。</span><br><span class="line">cc ^= &#x27;xx&#x27;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;b&quot; cc=&quot;xxasf&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存在属性cc，并且属性值是以 xx 结尾的元素。</span><br><span class="line">cc $= &#x27;xx&#x27;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;b&quot; cc=&quot;awwxx&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存在属性cc，并且属性值是以 xx 结尾的元素。</span><br><span class="line">cc $= &#x27;xx&#x27;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;b&quot; cc=&quot;awwxx&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在属性选择器右方括号前加 i用空格隔开，表示忽略大小写</span><br><span class="line">[cc $= &#x27;xx&#x27; i]</span><br><span class="line"></span><br><span class="line">div[cc $= &#x27;xx&#x27; i] &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同上，使用 s，表示区分大小写</span><br></pre></td></tr></table></figure>



<h2 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Child_combinator</span><br></pre></td></tr></table></figure>

<p>​        当使用  <code>&gt;</code> 选择符分隔两个元素时,它只会匹配那些作为第一个元素的**直接后代(**子元素)的第二元素. </p>
<p><strong>重点是 直接后代，而不是孙子代</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ele1 &gt; ele2 &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Class_selectors</span><br></pre></td></tr></table></figure>

<p>​        在一个HTML文档中，CSS类选择器会根据元素的类属性中的内容匹配元素。类属性被定义为一个以空格分隔的列表项，在这组类名中，必须有一项与类选择器中的类名完全匹配，此条样式声明才会生效。</p>
<p>​    简单来说，就是class的属性，值是以空格进行的分割，需要其中一个值满足类选择器的属性值，才能有作用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.class &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">他和属性选择器的具有相同的作用。</span><br><span class="line">[class ~= &#x27;class&#x27;] &#123; ... &#125;</span><br></pre></td></tr></table></figure>



<h2 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Descendant_combinator</span><br></pre></td></tr></table></figure>

<p>​        <strong>后代组合器</strong>（通常用单个空格（<code> </code>）字符表示）组合了两个选择器，如果第二个选择器匹配的元素具有与第一个选择器匹配的祖先（父母，父母的父母，父母的父母的父母等）元素，则它们将被选择。利用后代组合器的选择器称为后代选择器。</p>
<p>​    简单来说，就是，第二个元素是第一个元素的后代，但是可以不是直接后代。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.a .c &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;a&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div class=&quot;c&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">如同上面这样，a存在后代c，但是不是直接后代，可以使用后代选择器(` `), 而不能使用子选择器(`&gt;`)</span><br></pre></td></tr></table></figure>



<h2 id="通用兄弟选择器"><a href="#通用兄弟选择器" class="headerlink" title="通用兄弟选择器"></a>通用兄弟选择器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/CSS/General_sibling_combinator</span><br></pre></td></tr></table></figure>

<p>​        兄弟选择符，位置无须紧邻，只须同层级，<code>A~B</code> 选择<code>A</code>元素之后所有同层级<code>B</code>元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ele1 ~ ele2 &#123; ... &#125;</span><br></pre></td></tr></table></figure>



<h2 id="ID-选择器"><a href="#ID-选择器" class="headerlink" title="ID 选择器"></a>ID 选择器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/CSS/ID_selectors</span><br></pre></td></tr></table></figure>

<p>​        CSS ID 选择器会根据该元素的 ID 属性中的内容匹配元素,元素 ID 属性名必须与选择器中的 ID 属性名完全匹配，此条样式声明才会生效。</p>
<p><strong>注：</strong></p>
<p>​    一般一个html里面，一个id只能一个，如果有多个，那么这个就会选中多个。</p>
<p>​    id属性的值只有一个，不像使用class属性那样，可以有空格划分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#id &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">同属性选择器的</span><br><span class="line">[id=value] &#123; ... &#125;</span><br></pre></td></tr></table></figure>



<h2 id="选择器列表"><a href="#选择器列表" class="headerlink" title="选择器列表"></a>选择器列表</h2><p>选择器分组</p>
<p>​        CSS <strong>选择器列表</strong>（<code>,</code>），常被称为并集选择器或并集组合器，选择所有能被列表中的任意一个选择器选中的节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h1,</span><br><span class="line">#id,</span><br><span class="line">.class,</span><br><span class="line">.a &gt; span &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意点：</strong></p>
<p>​        选择器列表无效化，说的是当一个选择器不被支持，就会出现整条规则全部失效，我这里看了一个人写的，<a target="_blank" rel="noopener" href="https://www.xinran001.com/frontend/248.html">出现无效的伪选择器</a> 他的说明是如果是一个伪选择器无效的话，就会出现这个问题。但是如果是一个选择器的写法满足一个浏览器的cssom的构建，那么就不会出现这个问题。</p>
<p>​            解决这个问题的一个方法是使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:is"><code>:is()</code></a> 选择器，它会忽视它的参数列表中失效的选择器，但是由于 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:is"><code>:is()</code></a> 会影响优先级的计算方式，这么做的代价是，其中的所有选择器都会拥有相同的优先级。</p>
<h2 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Type_selectors</span><br></pre></td></tr></table></figure>

<p>​        CSS元素选择器(也称为类型选择器)通过node节点名称匹配元素.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ele &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">span &#123; ... &#125;</span><br></pre></td></tr></table></figure>



<h2 id="通配选择器"><a href="#通配选择器" class="headerlink" title="通配选择器"></a>通配选择器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Universal_selectors</span><br></pre></td></tr></table></figure>

<p>​        在CSS中,一个星号(<code>*</code>)就是一个通配选择器.它可以匹配任意类型的HTML元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>​        CSS3里面，*可以和命名空间搭配使用，命名空间，我现在也没有了解，我们后面在学。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ns|* - 会匹配ns命名空间下的所有元素</span><br><span class="line">*|* - 会匹配所有命名空间下的所有元素</span><br><span class="line">|* - 会匹配所有没有命名空间的元素</span><br></pre></td></tr></table></figure>



<h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes</span><br></pre></td></tr></table></figure>

<h3 id="常用的"><a href="#常用的" class="headerlink" title="常用的"></a>常用的</h3><p><strong>active</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:active </span><br><span class="line">可以代表按下按键和松开按键。常用于按钮和链接</span><br></pre></td></tr></table></figure>

<p><strong>focus</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">获得焦点时</span><br></pre></td></tr></table></figure>

<p><strong>hover</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">鼠标放在上面时触发</span><br></pre></td></tr></table></figure>

<p>MDN上有个描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:hover CSS伪类适用于用户使用指示设备虚指一个元素（没有激活它）的情况。这个样式会被任何与链接相关的伪类重写，像:link, :visited, 和 :active等。为了确保生效，:hover规则需要放在:link和:visited规则之后，但是在:active规则之前，按照LVHA的循顺序声明:link－:visited－:hover－:active。</span><br><span class="line"></span><br><span class="line">大致意思就是说， link会覆盖掉其他的样式，如果写在后面，其他的样式不会显示出来。</span><br></pre></td></tr></table></figure>

<p><strong>link</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">应该只能用于 a 标签，我使用span标签没有成功</span><br><span class="line">:link伪类选择器是用来选中元素当中的链接，所有未访问的链接（如果定义了visited伪元素），但是如果没有定义visited伪元素的话，那么就会将所有链接都选中，不管是不是访问过的。</span><br><span class="line">对于一个链接是否访问过，应该是通过href的值来进行的判断。</span><br><span class="line">因为link会覆盖其他伪元素的样式，所以书写顺序是：</span><br><span class="line">	:link — :visited — :hover — :active。:focus伪类选择器常伴随在:hover伪类选择器左右，需要根据你想要实现的效果确定它们的顺序。</span><br></pre></td></tr></table></figure>



<p><strong>disabled</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示被禁用的元素</span><br></pre></td></tr></table></figure>

<p><strong>enabled</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">没有被禁用的元素</span><br></pre></td></tr></table></figure>



<p><strong>invalid</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:invalid CSS 伪类 表示任意内容未通过验证的 &lt;input&gt; 或其他 &lt;form&gt; 元素 .</span><br></pre></td></tr></table></figure>

<p><strong>valid</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:valid CSS 伪类表示内容验证正确的&lt;input&gt; 或其他 &lt;form&gt; 元素。这能简单地将校验字段展示为一种能让用户辨别出其输入数据的正确性的样式。</span><br><span class="line"></span><br><span class="line">验证正确的展示</span><br></pre></td></tr></table></figure>

<p><strong>optional</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:optional</span><br><span class="line">表示 任意没有 required 属性的  &lt;input&gt;，&lt;select&gt; 或  &lt;textarea&gt; 元素</span><br></pre></td></tr></table></figure>

<p><strong>required</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:required</span><br><span class="line">表示设置了 required 属性的 &lt;input&gt;，&lt;select&gt; 或  &lt;textarea&gt; 元素</span><br></pre></td></tr></table></figure>

<p><strong>read-only</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:read-only</span><br><span class="line">	选中其中元素不可被用户编辑的状态</span><br><span class="line">与之对应的</span><br><span class="line">	read-write</span><br></pre></td></tr></table></figure>



<p><strong>first-child</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一组兄弟元素中的第一个元素。</span><br><span class="line"></span><br><span class="line">p:first-child，代表的是p的第一个</span><br></pre></td></tr></table></figure>

<p><strong>last-child</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一组兄弟元素中的最后一个元素。</span><br></pre></td></tr></table></figure>

<p><strong>not</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">反选</span><br><span class="line"></span><br><span class="line">:not(p)</span><br><span class="line">不要p标签的</span><br></pre></td></tr></table></figure>

<p><strong>nth-child</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:nth-child(an+b) 这个 CSS 伪类首先找到所有当前元素的兄弟元素，然后按照位置先后顺序从1开始排序，选择的结果为CSS伪类:nth-child括号中表达式（an+b）匹配到的元素集合（n=0，1，2，3...）。</span><br><span class="line"></span><br><span class="line">简单来说，:nth-child(an+b)，其中 an+b 的值的范围是 1~n，超过范围的不会显示，虽然 an+b 的范围是 1~n，但是n的范围却是 0~，因为我们使用 n+1 可以发现，每个都还是有，说明了这个事实。</span><br><span class="line"></span><br><span class="line">几个特殊值：使用后，不要再加n和b了</span><br><span class="line">	odd，奇数行</span><br><span class="line">	even，偶数行</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>​    不能写成 b+an 的形式，只能是 an+b</p>
<p>​    可以使用减号，<code>-</code>, 但是要注意一个问题，就是n的取值，貌似不是从 0~n，而是从0开始，不知道最终值是多少，所以对于 :nth-child(n-10)，还是会全部显示，但是使用 :nth-child(2n - 1)，就会发现不同。</p>
<p>​    所以一般要找前面n个，都是使用的 <code>-n+b</code>。</p>
<p>​    第二个不能使用n  2n-n，没有效果。</p>
<p><strong>nth-last-child</strong></p>
<p>​    从兄弟节点中从后往前匹配处于某些位置的元素</p>
<p><strong>注意:</strong> 这个伪类和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-child"><code>:nth-child</code></a> 基本一致, 但它是从<em>结尾</em>计数, 而不是从开始计数.</p>
<p><strong>only-child</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">匹配没有任何兄弟的元素</span><br><span class="line"></span><br><span class="line">.b</span><br><span class="line">	.c</span><br><span class="line">	.c</span><br><span class="line">.b</span><br><span class="line">	.c</span><br><span class="line">	</span><br><span class="line">	类似于上面的，不是通过 .b:only-child，因为在同层中，.b没有只存在一个的情况，使用 .c:only-child 就能找到。</span><br><span class="line"></span><br><span class="line">	等效的选择器还可以写成 :first-child:last-child或者:nth-child(1):nth-last-child(1),当然,前者的权重会低一点.</span><br></pre></td></tr></table></figure>



<p><strong>root</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:root 这个 CSS 伪类匹配文档树的根元素。对于 HTML 来说，:root 表示 &lt;html&gt; 元素，除了优先级更高之外，与 html 选择器相同。</span><br></pre></td></tr></table></figure>

<p><strong>target</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对目标元素的id进行一个匹配，当url中出现了这个id时显示，url的构造形式类似于vue-router 的hash模式</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;12&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">div:target &#123; &#125; </span><br><span class="line">当url为 http://xxxx#12 时，这里面的效果就会展示出来</span><br></pre></td></tr></table></figure>



<h1 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity</span><br></pre></td></tr></table></figure>

<p>简单来说，</p>
<p><strong>!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</strong></p>
<p>我们是使用的权重方式进行的判断优先级</p>
<p><strong>内联的权重是：1 0 0 0</strong></p>
<p><strong>id的权重是 1 0 0</strong></p>
<p><strong>class的权重是 1 0</strong></p>
<p><strong>标签的权重是 1</strong></p>
<p><strong>注意：</strong></p>
<p>​    权重是不会进位的，不会因为有11个class，就可以超过id</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://tallgy.gitee.io/2021/10/25/JavaScript/JavaScript-parseInt%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="tallgy">
      <meta itemprop="description" content="逐步学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tallgy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/25/JavaScript/JavaScript-parseInt%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">JavaScript-parseInt函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-25 19:41:27" itemprop="dateCreated datePublished" datetime="2021-10-25T19:41:27+08:00">2021-10-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-26 16:18:58" itemprop="dateModified" datetime="2021-10-26T16:18:58+08:00">2021-10-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/Global-Objects/" itemprop="url" rel="index"><span itemprop="name">Global_Objects</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="parseInt函数"><a href="#parseInt函数" class="headerlink" title="parseInt函数"></a>parseInt函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt</span><br></pre></td></tr></table></figure>

<p>​    <strong>parseInt(*string*, *radix*)</strong>  解析一个字符串并返回指定基数的十进制整数， <code>radix</code> 是2-36之间的整数，表示被解析字符串的基数。</p>
<h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><p><strong>string</strong></p>
<p>​        要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用  <code>ToString </code>抽象操作)。字符串开头的空白符将会被忽略。</p>
<p><strong>radix</strong></p>
<p>​        从 <code>2</code> 到 <code>36</code>，表示字符串的基数。例如指定 16 表示被解析值是十六进制数。请注意，10不是默认值！简单来说就是设置进制，一个2~36的进制</p>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>一个整数，</p>
<p>或者NaN</p>
<p>​    转换NaN的情况</p>
<p>​        <code>radix</code> 小于 <code>2</code> 或大于 <code>36</code> ，或</p>
<p>​        第一个非空格字符不能转换为数字。</p>
<p><strong>注意：</strong></p>
<p>​    这个在进行进制运算时，不是先转为十进制在运算，而是直接进行对应的进制转换，</p>
<p>​        比如：    33 ， 2 此时是：33转为2进制的转换，因为2进制每位数最大值是1，所以33直接NaN，但是如果是12，就会转化为1.</p>
<h2 id="面试问到的："><a href="#面试问到的：" class="headerlink" title="面试问到的："></a>面试问到的：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3, 10, 111];</span><br><span class="line">arr.map(parseInt)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">简单的解析一下，</span><br><span class="line">首先map内部的回调函数的三个参数分别为 value，index，array</span><br><span class="line">然后parseInt会使用两个参数，一个是要转换的字符串，一个是进制</span><br><span class="line">所以 按照顺序就会变成： 1,0	2,1		3,2		10,3	111,4</span><br><span class="line">	对于0，会使用默认形式，对于1，会直接NaN，对于后面的就按照正常进制的运算</span><br><span class="line">	所以结果是： 1,NaN,NaN,3,21</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://tallgy.gitee.io/2021/10/25/JavaScript/JavaScript-map%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="tallgy">
      <meta itemprop="description" content="逐步学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tallgy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/25/JavaScript/JavaScript-map%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">JavaScript-map函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-25 16:48:23" itemprop="dateCreated datePublished" datetime="2021-10-25T16:48:23+08:00">2021-10-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-26 15:17:03" itemprop="dateModified" datetime="2021-10-26T15:17:03+08:00">2021-10-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/Array/" itemprop="url" rel="index"><span itemprop="name">Array</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JavaScript之Array-map函数"><a href="#JavaScript之Array-map函数" class="headerlink" title="JavaScript之Array.map函数"></a>JavaScript之Array.map函数</h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map</span><br></pre></td></tr></table></figure>

<p><code>**map()**</code> 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。</p>
<p><strong>参数</strong></p>
<p>​    <strong>回调函数，callback</strong></p>
<p>​        参数分别为，value，index，array，第二个和第三个参数是可选的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const array1 = [1, 4, 9, 16];</span><br><span class="line"></span><br><span class="line">// pass a function to map</span><br><span class="line">const map1 = array1.map(x =&gt; x * 2);</span><br><span class="line"></span><br><span class="line">console.log(map1);</span><br><span class="line">// expected output: Array [2, 8, 18, 32]</span><br></pre></td></tr></table></figure>

<p>​    <strong>thisArg</strong></p>
<p>​        在执行callabck函数时，被用作 <code>this</code></p>
<h2 id="简单的源码实现"><a href="#简单的源码实现" class="headerlink" title="简单的源码实现"></a>简单的源码实现</h2><p>通过上面的参数描述，我们可以知道，</p>
<p>我们需要先对数组进行循环，然后将其带入callback，返回值会push入一个res数组，</p>
<p>然后因为第二个参数是this的指向，所以我们需要在判断是否携带了第二个参数**(  const _this = thisArg || this;)**</p>
<p>将其this的指向进行改变，使用了call方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function myMap(callback, thisArg) &#123;</span><br><span class="line">  const result = [];</span><br><span class="line">  const arr = this;</span><br><span class="line">  const _this = thisArg || this;</span><br><span class="line"></span><br><span class="line">  for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    result.push(callback.call(_this, arr[i], i, arr));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="一些面试时遇到的问题"><a href="#一些面试时遇到的问题" class="headerlink" title="一些面试时遇到的问题"></a>一些面试时遇到的问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3, 10, 111];</span><br><span class="line"></span><br><span class="line">arr.map(parseInt)</span><br><span class="line"></span><br><span class="line">这个可能有的没有理解的话会有点懵逼</span><br><span class="line">其实理解了就很简单了。</span><br><span class="line">这就是把parseInt作为一个回调函数传递给了map，</span><br><span class="line">map的回调函数的参数是，value， index， arr</span><br><span class="line">而parseInt，可以带两个参数，这两个参数，一个是要转化的字符串（数字也可以），一个是要转化的进制。</span><br><span class="line"></span><br><span class="line">所以我们就能够理解了，</span><br><span class="line">对于 arr 1， 2， 3， 10， 111</span><br><span class="line">会分别传递</span><br><span class="line">	1， 0</span><br><span class="line">	2， 1</span><br><span class="line">	3， 2</span><br><span class="line">	10， 3</span><br><span class="line">	111， 4</span><br><span class="line">其中，0代表了默认转换，对于字符串没有进制前缀的，就是默认十进制，具体的转换规则后续写 parseInt 的时候再说明。</span><br><span class="line"></span><br><span class="line">我们可以看出，1对应的默认进制转换，2对应的1进制，3对应的2进制，10对应的3进制，111对应的4进制，因为parseInt的第二个参数范围是2-36，所以对于其他的除0以外直接NaN。</span><br><span class="line">所以对应的结果是 1, NaN, NaN, 3, 21.</span><br></pre></td></tr></table></figure>

<p>对于其他的就也可以按照这个思路进行思考了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://tallgy.gitee.io/2021/10/24/CSS/border-radius%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="tallgy">
      <meta itemprop="description" content="逐步学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tallgy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/24/CSS/border-radius%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">border-radius的原理和使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-24 10:53:12" itemprop="dateCreated datePublished" datetime="2021-10-24T10:53:12+08:00">2021-10-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-26 15:19:12" itemprop="dateModified" datetime="2021-10-26T15:19:12+08:00">2021-10-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSS/" itemprop="url" rel="index"><span itemprop="name">CSS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="border-radius的原理和使用"><a href="#border-radius的原理和使用" class="headerlink" title="border-radius的原理和使用"></a>border-radius的原理和使用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius</span><br></pre></td></tr></table></figure>



<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>首先我们可以知道 <code>border-radius</code> 是四个属性的简写，所以我们先理解四个属性的值的效果。</p>
<p><code>border-top-right-radius</code> <code>border-top-left-radius</code></p>
<p> <code>border-bottom-right-radius</code> <code>border-bottm-left-radius</code></p>
<p>我们取其中一个</p>
<p><code>border-top-right-radius</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-right-radius</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-top-right-radius属性设置元素的右上角弧形，这个圆弧可能是一个椭圆，或者其中一个值是0的话，就是没有圆弧，换句话就是说拐角是方形的。</span><br></pre></td></tr></table></figure>

<img src="/2021/10/24/CSS/border-radius%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/image-20211025104917514.png" alt="image-20211025104917514" style="zoom:50%;">

<p>通过图片我们可以知道 <code>border-top-right-radius</code> 的值是一个据 top 和 right 的一个半径，然后画弧所裁剪出来的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">border-top-right-radius: radius               </span><br><span class="line">/* the corner is a circle    */  E.g. border-top-right-radius: 3px</span><br><span class="line">border-top-right-radius: horizontal vertical  </span><br><span class="line">/* the corner is an ellipsis */  E.g. border-top-right-radius: 0.5em 1em</span><br></pre></td></tr></table></figure>

<p>通过例子也可以知道，对于一个值，说明了 横轴<code>horizontal</code> 和 数轴<code>vertical</code> 的值相等，对于两个值，那么就说明了第一值是横轴，第二个值是数轴。</p>
<p>然后得到横轴和数轴的半径后，相对进行偏移，然后画出一个圆形或者一个椭圆形，所裁剪出来的值。就是得到的效果。</p>
<p>对于值是%的，那么宽度就会相对于宽度，高度就会相对于高度。</p>
<h3 id="对于超过-50-的计算方式"><a href="#对于超过-50-的计算方式" class="headerlink" title="对于超过 50% 的计算方式"></a>对于超过 50% 的计算方式</h3><p>原文链接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://zhuanlan.zhihu.com/p/20128284</span><br></pre></td></tr></table></figure>

<p>简单来说就是对于 <strong>相邻的角的半径和超过了对应的盒子的边的长度，那么浏览器要重新计算保证它们不会重合。</strong></p>
<p>就是会同时进行缩放。来保证不会重合。</p>
<h2 id="水平和垂直从哪个位置开始偏移"><a href="#水平和垂直从哪个位置开始偏移" class="headerlink" title="水平和垂直从哪个位置开始偏移"></a>水平和垂直从哪个位置开始偏移</h2><h3 id="我们先看使用px的计算"><a href="#我们先看使用px的计算" class="headerlink" title="我们先看使用px的计算"></a>我们先看使用px的计算</h3><p>先说结果，结果是，<strong>px的计算是相对于border的位置开始的偏移。</strong></p>
<p>然后我们再看代码和执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .d &#123;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">      background-color: #f00;</span><br><span class="line">      border: blue solid 10px;</span><br><span class="line">      padding: 10px;</span><br><span class="line">      margin: 10px;</span><br><span class="line">      border-radius: 10px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;d&quot;&gt;123&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<img src="/2021/10/24/CSS/border-radius%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/image-20211025104342522.png" alt="image-20211025104342522" style="zoom:50%;">



<h3 id="我们再看使用-百分号-进行的计算"><a href="#我们再看使用-百分号-进行的计算" class="headerlink" title="我们再看使用 百分号% 进行的计算"></a>我们再看使用 百分号% 进行的计算</h3><p>意思是一样的，会按照你的宽高加上你的border的宽高，然后乘以 百分比。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开始我这样写，以为10%应该是 50px，但是忘了border有上有下，所以真正的宽高是550px，所以50%是55px，后面才搞清楚</span><br><span class="line"></span><br><span class="line">width: 450px;</span><br><span class="line">height: 450px;</span><br><span class="line">background-color: #f00;</span><br><span class="line">border: blue solid 50px;</span><br><span class="line">border-radius: 10%;</span><br></pre></td></tr></table></figure>



<h2 id="如何裁剪"><a href="#如何裁剪" class="headerlink" title="如何裁剪"></a>如何裁剪</h2><p>这个就是自己的理解了，我们可以看到，对于存在了border的，当你的数值超过了一定值之后，你的content也会变成弧边，而这个值就是border的宽度。</p>
<p><strong>所以这个裁剪的方法是：</strong></p>
<ul>
<li><p>先计算出radius的偏移量x，y</p>
</li>
<li><p>然后从border的边框开始进行x，y的偏移，并且半径值也为x，y画弧，将border进行了裁剪。</p>
</li>
<li><p>然后如果x，y的偏移量在content里面了（这个content是包含了padding的），那么就会再对content进行裁剪，而裁剪的半径就是x，y这个点到content边界的半径。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    * &#123;</span><br><span class="line">      padding: 0;</span><br><span class="line">      margin: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    .d &#123;</span><br><span class="line">      width: 450px;</span><br><span class="line">      height: 450px;</span><br><span class="line">      background-color: #f00;</span><br><span class="line">      border: blue solid 25px;</span><br><span class="line">      border-top: blue solid 30px;</span><br><span class="line">      border-left: blue solid 10px;</span><br><span class="line">      padding: 50px;</span><br><span class="line">      margin: 10px;</span><br><span class="line">      border-top-left-radius: 30px 40px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;d&quot;&gt;123&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/10/24/CSS/border-radius%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/image-20211025155459099.png" alt="image-20211025155459099" style="zoom:67%;">



<h2 id="简写参数"><a href="#简写参数" class="headerlink" title="简写参数"></a>简写参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">border-radius: top-left top-right bottom-right bottom-left;</span><br><span class="line">上左，上右，下右，下左，这是一个从上左开始的一个顺时针顺序。</span><br><span class="line">按此顺序设置每个 radii 的四个值。如果省略 bottom-left，则与 top-right 相同。如果省略 bottom-right，则与 top-left 相同。如果省略 top-right，则与 top-left 相同。</span><br><span class="line">	参考链接：(https://www.w3school.com.cn/cssref/pr_border-radius.asp)</span><br><span class="line">意思就是，如果在省略的情况下，那么就是最后一个开始是没有值的，而前面的才有值，然后对没有值的那个，他的值就是对面的值，如果对面也没有值，那么他的值就和旁边的相等(此时就是只有一个参数)</span><br><span class="line"></span><br><span class="line">按照上面的意思来理解的话，那么很多简写参数都可以理解了。我这里就直接统计结果。</span><br></pre></td></tr></table></figure>



<h3 id="第一步，将参数从简写的个数化为完整个数"><a href="#第一步，将参数从简写的个数化为完整个数" class="headerlink" title="第一步，将参数从简写的个数化为完整个数"></a>第一步，将参数从简写的个数化为完整个数</h3><h4 id="一个参数-border-radius-50px"><a href="#一个参数-border-radius-50px" class="headerlink" title="一个参数 border-radius: 50px;"></a>一个参数 <code>border-radius: 50px;</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">border-radius: 50px;</span><br><span class="line"></span><br><span class="line">只有一个 top-left </span><br><span class="line">那么，bottom-right = top-left = 50</span><br><span class="line">并且 bottom-left = top-right = top-left = 50</span><br><span class="line"></span><br><span class="line">border-radius: 50px 50px 50px 50px;</span><br></pre></td></tr></table></figure>



<h4 id="两个参数-border-radius-50px-30px"><a href="#两个参数-border-radius-50px-30px" class="headerlink" title="两个参数 border-radius: 50px 30px;"></a>两个参数 <code>border-radius: 50px 30px;</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">border-radius: 50px 30px;</span><br><span class="line"></span><br><span class="line">有两个，那么这两个就是 top-left 和 top-right</span><br><span class="line">对应的 bottom-left = top-right = 30</span><br><span class="line">bottom-right = top-left = 50</span><br><span class="line"></span><br><span class="line">border-radius: 50px 30px 50px 30px;</span><br></pre></td></tr></table></figure>



<h4 id="三个参数-border-radius-50px-30px-40px"><a href="#三个参数-border-radius-50px-30px-40px" class="headerlink" title="三个参数 border-radius: 50px 30px 40px;"></a>三个参数 <code>border-radius: 50px 30px 40px;</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">border-radius: 50px 30px 40px;</span><br><span class="line"></span><br><span class="line">有三个，那么就只有最后一个 bottom-left 没有</span><br><span class="line">那么 bottom-left 等于对面的 top-right = 30px</span><br><span class="line"></span><br><span class="line">border-radius: 50px 30px 40px 30px;</span><br></pre></td></tr></table></figure>



<h4 id="四个参数-border-radius-50px-40px-30px-20px"><a href="#四个参数-border-radius-50px-40px-30px-20px" class="headerlink" title="四个参数 border-radius: 50px 40px 30px 20px;"></a>四个参数 <code>border-radius: 50px 40px 30px 20px;</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">border-radius: 50px 40px 30px 20px;</span><br><span class="line"></span><br><span class="line">没啥说的。</span><br></pre></td></tr></table></figure>



<h4 id="对于参数里面带有-符号的-border-radius-4px-3px-6px-2px-4px"><a href="#对于参数里面带有-符号的-border-radius-4px-3px-6px-2px-4px" class="headerlink" title="对于参数里面带有 / 符号的 border-radius: 4px 3px 6px / 2px 4px;"></a>对于参数里面带有 <code>/</code> 符号的 <code>border-radius: 4px 3px 6px / 2px 4px;</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">border-radius: 4px 3px 6px / 2px 4px;</span><br><span class="line"></span><br><span class="line">这个分为两个部分</span><br><span class="line">第一部分 4 3 6 将其转化为对应的 horizontal</span><br><span class="line">	所以为 4 3 6 3</span><br><span class="line">第二部分 2 4 将其转化为对应的 vertical</span><br><span class="line">	所以为 2 4 2 4</span><br><span class="line">	</span><br><span class="line">border-radius: 4px 3px 6px 3px / 2px 4px 2px 4px;</span><br><span class="line">	</span><br><span class="line">然后结果就是</span><br><span class="line">border-top-left-radius:     4px 2px;</span><br><span class="line">border-top-right-radius:    3px 4px;</span><br><span class="line">border-bottom-right-radius: 6px 2px;</span><br><span class="line">border-bottom-left-radius:  3px 4px;</span><br></pre></td></tr></table></figure>



<h3 id="第二步，将其转化为-border-radius"><a href="#第二步，将其转化为-border-radius" class="headerlink" title="第二步，将其转化为 border-*-*-radius"></a>第二步，将其转化为 <code>border-*-*-radius</code></h3><h4 id="对于没有带-符号的-border-radius-50px-40px-30px-20px"><a href="#对于没有带-符号的-border-radius-50px-40px-30px-20px" class="headerlink" title="对于没有带 / 符号的 border-radius: 50px 40px 30px 20px;"></a>对于没有带 <code>/</code> 符号的 <code>border-radius: 50px 40px 30px 20px;</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">其 horizontal 和 vertical 的值相等。</span><br><span class="line"></span><br><span class="line">border-radius: 50px 40px 30px 20px;</span><br><span class="line"></span><br><span class="line">border-top-left-radius:     50px 50px;</span><br><span class="line">border-top-right-radius:    40px 40px;</span><br><span class="line">border-bottom-right-radius: 30px 30px;</span><br><span class="line">border-bottom-left-radius:  20px 20px;</span><br></pre></td></tr></table></figure>



<h4 id="对于带有-符号的-border-radius-4px-3px-6px-3px-2px-4px-2px-4px"><a href="#对于带有-符号的-border-radius-4px-3px-6px-3px-2px-4px-2px-4px" class="headerlink" title="对于带有 / 符号的 border-radius: 4px 3px 6px 3px / 2px 4px 2px 4px;"></a>对于带有 <code>/</code> 符号的 <code>border-radius: 4px 3px 6px 3px / 2px 4px 2px 4px;</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">会将 / 前的作为每一个的 horizontal </span><br><span class="line">/ 后的作为每一个的 vertical</span><br><span class="line"></span><br><span class="line">border-radius: 4px 3px 6px 3px / 2px 4px 2px 4px;</span><br><span class="line"></span><br><span class="line">border-top-left-radius:     4px 2px;</span><br><span class="line">border-top-right-radius:    3px 4px;</span><br><span class="line">border-bottom-right-radius: 6px 2px;</span><br><span class="line">border-bottom-left-radius:  3px 4px;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://tallgy.gitee.io/2021/10/23/%E5%85%B6%E4%BB%96/HTTP%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="tallgy">
      <meta itemprop="description" content="逐步学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tallgy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/23/%E5%85%B6%E4%BB%96/HTTP%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">HTTP概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-23 23:13:22" itemprop="dateCreated datePublished" datetime="2021-10-23T23:13:22+08:00">2021-10-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-26 15:16:54" itemprop="dateModified" datetime="2021-10-26T15:16:54+08:00">2021-10-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>找不到说啥，直接放个MDN文档</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview</span><br></pre></td></tr></table></figure>

<img src="/2021/10/23/%E5%85%B6%E4%BB%96/HTTP%E6%A6%82%E8%BF%B0/image-20211024100324347.png" alt="image-20211024100324347" style="zoom:67%;">



<h2 id="版本迭代"><a href="#版本迭代" class="headerlink" title="版本迭代"></a>版本迭代</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP</span><br></pre></td></tr></table></figure>

<h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h3><p>也被称为 <strong>单行协议</strong> </p>
<p>请求由单行指令构成，以唯一可用方法<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a>开头，其后跟目标资源的路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /mypage.html</span><br></pre></td></tr></table></figure>

<p>响应就只包含了响应文档本身，就是HTML文件</p>
<p>并且因为不包含响应头，所以只有HTML文件可以进行传输。</p>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大的变化是支持了传输其他文件，默认是短连接，支持GET、POST、 HEAD请求</span><br></pre></td></tr></table></figure>

<ul>
<li>协议版本信息现在会随着每个请求发送（<code>HTTP/1.0</code>被追加到了<code>GET</code>行）。</li>
<li><strong>状态码会在响应开始时发送</strong>，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）。</li>
<li>引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性。</li>
<li>在新HTTP头的帮助下，具备了传输除纯文本HTML文件以外其他类型文档的能力（感谢<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a>头）。</li>
</ul>
<p><strong>默认是短连接，一次请求会建立一次TCP连接，请求结束就断开。</strong>可以通过一个 <code>Connection: keep-alive</code>字段使服务器不关闭连接。服务器同时也会响应这个字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /mypage.html HTTP/1.0</span><br><span class="line">User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大的变化就是支持了持久连接，默认长连接。不同自己声明 `Connection: keep-alive` ，增加了 `HOST` ，增加了请求方式，支持断点续传功能。</span><br></pre></td></tr></table></figure>

<ul>
<li>连接可以复用，节省了多次打开TCP连接加载网页文档资源的时间。</li>
<li>增加管线化技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。</li>
<li>支持响应分块。</li>
<li>引入额外的缓存控制机制。</li>
<li>引入内容协商机制，包括语言，编码，类型等，并允许客户端和服务器之间约定以最合适的内容进行交换。</li>
<li>感谢<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Host"><code>Host</code></a>头，能够使不同域名配置在同一个IP地址的服务器上。</li>
</ul>
<p><strong>Host</strong> 请求头指明了请求将要发送到的服务器主机名和端口号。</p>
<p>如果没有包含端口号，会自动使用被请求服务的默认端口（比如HTTPS URL使用443端口，HTTP URL使用80端口）。</p>
<p>所有HTTP/1.1 请求报文中必须包含一个<code>Host</code>头字段。对于缺少<code>Host</code>头或者含有超过一个<code>Host</code>头的HTTP/1.1 请求，可能会收到<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/400"><code>400</code></a>（Bad Request）状态码。</p>
<p>所有请求都是通过一个连接实现的。就是持久连接。服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭TCP连接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /en-US/docs/Glossary/Simple_header HTTP/1.1</span><br><span class="line">Host: developer.mozilla.org</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Referer: https://developer.mozilla.org/en-US/docs/Glossary/Simple_header</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大的区别，协议为二进制协议，服务器主动推送，以及 headers 压缩</span><br></pre></td></tr></table></figure>

<ul>
<li>HTTP/2是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。</li>
<li>这是一个复用协议。并行的请求能在同一个链接中处理，移除了HTTP/1.x中顺序和阻塞的约束。</li>
<li>压缩了headers。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</li>
<li>其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。</li>
</ul>
<h3 id="服务器推送方式"><a href="#服务器推送方式" class="headerlink" title="服务器推送方式"></a>服务器推送方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html</span><br></pre></td></tr></table></figure>

<p><strong>WebSockets</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API</span><br></pre></td></tr></table></figure>

<p><strong>Server-sent events</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events</span><br></pre></td></tr></table></figure>



<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p>HTTP/1.x有三个，HTTP/2新增了其他的连接管理模型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x</span><br></pre></td></tr></table></figure>



<p>HTTP/1.x的三个连接</p>
<p>短连接，长连接，流水线</p>
<img src="/2021/10/23/%E5%85%B6%E4%BB%96/HTTP%E6%A6%82%E8%BF%B0/image-20211024104204389.png" alt="image-20211024104204389" style="zoom:67%;">



<h3 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h3><p>​        每一个 HTTP 请求都由它自己独立的连接完成；这意味着发起每一个 HTTP 请求之前都会有一次 TCP 握手，而且是连续不断的。</p>
<p>​        简单来说就是每次请求都要建立连接，请求结束关闭连接，造成了大量的连接时间的浪费。</p>
<p>​        这是 HTTP/1.0 的默认模型(如果没有指定 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection"><code>Connection</code></a> 协议头，或者是值被设置为 <code>close</code>)。而在 HTTP/1.1 中，只有当 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection"><code>Connection</code></a> 被设置为 <code>close</code> 时才会用到这个模型。</p>
<h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>​        在HTTP/1.1被设计出来之前：<code>Connection: keep-alive</code>被作为一个请求头，做成了长连接的效果。</p>
<p>​        为了缓解这些问题，<em>长连接</em> 的概念便被设计出来了，甚至在 HTTP/1.1 之前。或者这被称之为一个 <em>keep-alive</em> 连接。</p>
<h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP 流水线在现代浏览器中并不是默认被启用的：</span><br><span class="line">	Web 开发者并不能轻易的遇见和判断那些搞怪的代理服务器的各种莫名其妙的行为。</span><br><span class="line">	正确的实现流水线是复杂的：传输中的资源大小，多少有效的 RTT 会被用到，还有有效带宽，流水线带来的改善有多大的影响范围。不知道这些的话，重要的消息可能被延迟到不重要的消息后面。这个重要性的概念甚至会演变为影响到页面布局！因此 HTTP 流水线在大多数情况下带来的改善并不明显。</span><br><span class="line">	流水线受制于 HOL 问题。</span><br><span class="line">由于这些原因，流水线已经被更好的算法给代替，如 multiplexing，已经用在 HTTP/2。</span><br></pre></td></tr></table></figure>

<p>简单理解就是说，直接发送连续的请求，不需要等待每次的响应。</p>
<h3 id="域名分片"><a href="#域名分片" class="headerlink" title="域名分片"></a>域名分片</h3><p>简单的理解就是为域名多建立几个连接。以实现并发请求。但是HTTP/2支持客户端的并发请求</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://tallgy.gitee.io/2021/10/22/%E5%85%B6%E4%BB%96/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="tallgy">
      <meta itemprop="description" content="逐步学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tallgy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/22/%E5%85%B6%E4%BB%96/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">浏览器缓存策略</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-22 21:43:10" itemprop="dateCreated datePublished" datetime="2021-10-22T21:43:10+08:00">2021-10-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-26 15:30:06" itemprop="dateModified" datetime="2021-10-26T15:30:06+08:00">2021-10-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">浏览器</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="浏览器缓存策略"><a href="#浏览器缓存策略" class="headerlink" title="浏览器缓存策略"></a>浏览器缓存策略</h1><p><strong>参考文章</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://juejin.cn/post/6844903757872889870</span><br><span class="line">MDN</span><br><span class="line">https://juejin.cn/post/6844903737538920462</span><br></pre></td></tr></table></figure>



<p><strong>先说一下什么是缓存</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">缓存就是会将一些不会经常更改的图片文件等资源存储下来，下次访问的时候会优先读取本地的资源进行显示，这样既能减轻服务器的负载，也能加快页面的显示。</span><br><span class="line">这时可能就可能会问，那如果资源有了改变怎么办，所以这时候就有了强缓存和协商缓存两种。</span><br></pre></td></tr></table></figure>



<p><strong>浏览器缓存策略分为</strong></p>
<p>​    <strong>强缓存</strong></p>
<p>​        强缓存就是直接从本地进行读取，不需要向服务器端进行获取资源。因此很快。</p>
<p>​        在命中强缓存的情况下，状态码为 200，但是size显示from disk cache或from memory cache</p>
<p>​    <strong>协商缓存</strong></p>
<p>​        协商缓存就是会请求，但是会将一个文件的信息加入到请求头，然后服务器端进行判断，来决定是否要更新浏览器的资源。</p>
<p>​        会将 <code>Last-Modified</code> 和 <code>Etag</code> 放入请求头，然后服务器就会进行比对，如果命中协商缓存，状态码为304。否则会将资源传输过来。</p>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>在进行请求的时候，不会向服务器发送请求，直接从缓存中读取资源，但是状态码是200</p>
<p>如何进行强缓存，简单来说就是我们请求资源之后，服务器会返回一个请求头。浏览器后续就会根据这个请求头进行判断是否命中强缓存。</p>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>​        对于强缓存的请求头，有 <strong>Expires</strong> 和 <strong>Cache-Control</strong>，但是因为<strong>Cache-Control</strong> 是HTTP/1.1的产物，所以，优先级高于 Expires。</p>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires</span><br></pre></td></tr></table></figure>

<p>HTTP/1.0</p>
<p>​    缓存过期时间，用来指定资源到期的时间。</p>
<p>​        缺点，是通过本地时间进行的判断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<p>​    如果在<code>Cache-Contro</code>响应头设置了<code>max-age</code>或者<code>s-max-age</code>指令，那么<code>Expires</code>头会被忽悠。</p>
<h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>HTTP/1.1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control</span><br></pre></td></tr></table></figure>

<p><strong>语法</strong>：</p>
<ul>
<li>不区分大小写，但建议使用小写。</li>
<li>多个指令以逗号分隔。</li>
<li>具有可选参数，可以用令牌或者带引号的字符串语法。</li>
</ul>
<p><strong>默认值：private</strong></p>
<p><strong>指令</strong>：</p>
<p><strong>可缓存性指令：</strong></p>
<p><strong>public：</strong></p>
<p>​        表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。</p>
<p>​        （例如：1.该响应没有<code>max-age</code>指令或<code>Expires</code>消息头；</p>
<p>​                        2. 该响应对应的请求方法是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST">POST</a> 。）</p>
<p><strong>private：</strong></p>
<p>​        表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容。</p>
<p>​        比如：对应用户的本地浏览器。</p>
<p><strong>no-cache</strong>:</p>
<p>​        在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证(协商缓存验证)。</p>
<p><strong>no-store</strong>：</p>
<p>​        缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。</p>
<p><strong>到期：</strong></p>
<p><strong>max-age</strong>：</p>
<p>​        设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与<code>Expires</code>相反，时间是相对于请求的时间。</p>
<p><strong>s-maxage</strong>：</p>
<p>​        覆盖<code>max-age</code>或者<code>Expires</code>头，但是仅适用于共享缓存(比如各个代理)，私有缓存会忽略它。</p>
<p><strong>max-stale</strong>：</p>
<p>​        表明客户端愿意接收一个已经过期的资源。可以设置一个可选的秒数，表示响应不能已经过时超过该给定的时间。</p>
<p><strong>min-fresh</strong>：</p>
<p>​        表示客户端希望获取一个能在指定的秒数内保持其最新状态的响应。</p>
<p><strong>重新验证与加载：</strong></p>
<p><strong>must-revalidate</strong>：</p>
<p>​        一旦资源过期（比如已经超过<code>max-age</code>），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。</p>
<img src="/2021/10/22/%E5%85%B6%E4%BB%96/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/image-20211023161739229.png" alt="image-20211023161739229" style="zoom:67%;">

<p>图片来源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://juejin.cn/post/6844903757872889870</span><br></pre></td></tr></table></figure>



<p><strong>需要进行重新验证，这个就是会进行协商缓存：</strong></p>
<p>​        指定 <code>no-cache</code> 或 <code>max-age=0, must-revalidate</code> 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起 HTTP 请求，但当缓存内容仍有效时可以跳过 HTTP 响应体的下载。</p>
<p><strong>注意：</strong></p>
<p>​    如果服务器关闭或失去连接，下面的指令可能会造成使用缓存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=0</span><br></pre></td></tr></table></figure>



<h3 id="在强缓存时间内如何更新资源"><a href="#在强缓存时间内如何更新资源" class="headerlink" title="在强缓存时间内如何更新资源"></a>在强缓存时间内如何更新资源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://juejin.cn/post/6844903737538920462#heading-5</span><br></pre></td></tr></table></figure>

<p>虽然强缓存很好，但是有一个问题，如果在强缓存时间内，我的文件资源发生了更新，那该怎么解决呢？<code>（这个是我面试的时候问到的，一下把我人问傻了。）</code></p>
<p>这里我后面去了解了：</p>
<p>​    简单来说就是对于资源文件需要在发生了改变之后，可以让客户端再请求一次，方法就是将文件的名字在每次修改之后会发生改变，所以每次修改了之后，客户端要请求的文件名发生了改变，就会重新再进行一次请求了。这里对于文件名的方式使用<code>hash</code>。</p>
<p>​    HTML：使用协商缓存，因为里面会存储资源文件的路径，在每次更新之后里面的路径需要修改，所以使用协商缓存更合理。</p>
<p>​    对于　CSS／JS／图片：使用强缓存，对于一个文件名带上一个 hash 值。在每次文件进行了修改之后，名字后面的hash就会发生改变。所以客户端就会重新请求。</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>​        会在请求头加上：<code>If-None-Match</code>和<code>If-Modified-Since</code></p>
<p>​        分别对应了服务器响应头的：<code>ETag</code> 和  <code>Last-Modified</code></p>
<p>ETag 优先级高于 Last-Modified</p>
<h3 id="If-Modified-Since-与-Last-Modified："><a href="#If-Modified-Since-与-Last-Modified：" class="headerlink" title="If-Modified-Since 与  Last-Modified："></a><strong>If-Modified-Since</strong> 与  <strong>Last-Modified</strong>：</h3><p><strong>Last-Modified</strong>：</p>
<p>​    这个是服务器端的返回的响应头。</p>
<p><strong>If-Modified-Since</strong>：</p>
<p>​    这个是客户端的请求的请求头。</p>
<h4 id="Last-Modified："><a href="#Last-Modified：" class="headerlink" title="Last-Modified："></a><strong>Last-Modified</strong>：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified</span><br></pre></td></tr></table></figure>

<p>​        这个是根据上一次请求资源时，服务器所返回的<strong>Last-Modified</strong>，这个作为一个响应的头部。其中包含源头服务器认定的资源做出修改的日期及时间</p>
<p>​        包含有  <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since"><code>If-Modified-Since</code></a> 或 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since"><code>If-Unmodified-Since</code></a> 首部的条件请求会使用这个字段。 </p>
<h4 id="If-Modified-Since："><a href="#If-Modified-Since：" class="headerlink" title="If-Modified-Since："></a><strong>If-Modified-Since</strong>：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since</span><br></pre></td></tr></table></figure>

<p>​        服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200"><code>200</code></a> 。</p>
<p>​        如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/304"><code>304</code></a> 响应，而在 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified"><code>Last-Modified</code></a> 首部中会带有上次修改时间。<strong>（注：虽然返回了304，但是会有last-modified的头部返回，因此浏览器下次请求时，会使用的是此时服务器端返回过来的last-modified，而不是以前的。）</strong></p>
<p>​        <code>If-Modified-Since</code> 只可以用在 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a> 或 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD"><code>HEAD</code></a> 请求中。</p>
<p>​        当与 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match"><code>If-None-Match</code></a> 一同出现时，它（**<code>If-Modified-Since</code>**）会被忽略掉，除非服务器不支持 <code>If-None-Match</code>。</p>
<p><strong>If-Unmodified-Since：</strong></p>
<p>​        这个我没有了解。</p>
<p><strong>使用上面这个的弊端：</strong></p>
<p>​        对于没有进行修改，但是有过保存导致 Last-Modified 被修改，无法命中。</p>
<p>​        这个只能以秒计时，所以对于秒以内的修改文件，不能返回。</p>
<h3 id="If-None-Match-和-ETag"><a href="#If-None-Match-和-ETag" class="headerlink" title="If-None-Match 和 ETag"></a>If-None-Match 和 ETag</h3><p><strong>ETag</strong>：</p>
<p>​    这个是服务器端的返回的响应头。</p>
<p><strong>If-None-Match</strong>：</p>
<p>​    这个是客户端的请求的请求头。</p>
<h4 id="ETag："><a href="#ETag：" class="headerlink" title="ETag："></a><strong>ETag</strong>：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag</span><br></pre></td></tr></table></figure>

<p>简单来说就是一个唯一标识资源的一个特殊符号，</p>
<p>通常计算方式是：</p>
<p>​    <strong>使用内容的散列，最后修改时间戳的哈希值，或简单地使用版本号</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://juejin.cn/post/6844903737538920462</span><br><span class="line">这里有将比较详细的计算方式，我这里就不做过多的说明。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">作用：</span><br><span class="line">	避免空中碰撞</span><br><span class="line">	缓存未更改的资源，就是304.</span><br></pre></td></tr></table></figure>



<h5 id="避免空中碰撞"><a href="#避免空中碰撞" class="headerlink" title="避免空中碰撞"></a>避免空中碰撞</h5><p>MDN上有说有这句话：</p>
<p>​    <strong>而如果内容发生了变化，使用ETag有助于防止资源的同时更新相互覆盖（“空中碰撞”）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag#避免“空中碰撞”</span><br></pre></td></tr></table></figure>

<p>大概的意思就是说，</p>
<p>​        我在客户端进行编辑共享文档时<code>（共享文档就是说可以被多人查看和编辑的）</code>，最开始拿到的文档是最新的。</p>
<p>​        但是在编辑的过程中，可能别人也有编辑，但是比我上传的早，所以，在我准备上传一个共享文档时，服务器端的文档已经被别人修改过了，但是此时我的客户端的文档因为没有重新进行请求，所以还是没有被修改过的，</p>
<p>​        此时如果没有先进行一次判断 ETag 值的话，就会发生相互覆盖，这个就是空中碰撞。</p>
<p>​        避免就是会先进行 ETag 匹配检查是否为最新版，否则报 412 前提条件失败错误。</p>
<p><code>（此时这个 ETag 会放在 If-Match 的请求头中。）</code></p>
<p><strong>注：</strong></p>
<p>​        如果给定URL中的资源更改，则一定要生成新的 Etag 值。 因此 Etags 类似于指纹，也可能被某些服务器用于跟踪。 比较 etags 能快速确定此资源是否变化，但也可能被跟踪服务器永久存留。<strong>（我能理解到 ETag 可能用于快速比较一个文件是否发生过修改，因为他是一个文根据文件的相关信息进行的一个算法生成的一个值，但是我不清楚什么是会被跟踪服务器存留）</strong></p>
<h5 id="缓存未更改的资源"><a href="#缓存未更改的资源" class="headerlink" title="缓存未更改的资源"></a>缓存未更改的资源</h5><p>​        对于用户访问一个URL时，显示了资源过期且不可用，客户端就发送 ETag 的值 作为 If-None-Match 的请求头，如果资源没有更改，那么服务器将会返回不带响应体的 304 状态。</p>
<h4 id="If-None-Match："><a href="#If-None-Match：" class="headerlink" title="If-None-Match："></a><strong>If-None-Match</strong>：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match</span><br></pre></td></tr></table></figure>

<p><code>If-None-Match</code> 和 <code>If-Match</code> 的区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://datatracker.ietf.org/doc/html/rfc7232#section-3.1</span><br></pre></td></tr></table></figure>

<p>If-None-Match</p>
<p>​    使用的是 弱比较算法。</p>
<p>​    常用于 GET 请求的，请求最新资源的方式</p>
<p>If-Match</p>
<p>​    使用的是 强比较算法。</p>
<p>​    常用于 POST  PUT，DELETE 状态改变方法，防止多个用户同时操作的意外覆盖。</p>
<h2 id="后端设置方式"><a href="#后端设置方式" class="headerlink" title="后端设置方式"></a>后端设置方式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参考文章</span><br><span class="line">https://juejin.cn/post/6844903737538920462#heading-11</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&#x27;Cache-Control&#x27;, &#x27;public, max-age=xxx&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res.setHeader(&#x27;Cache-Control&#x27;, &#x27;public, max-age=0&#x27;);</span><br><span class="line">res.setHeader(&#x27;Last-Modified&#x27;, xxx);</span><br><span class="line">res.setHeader(&#x27;ETag&#x27;, xxx);</span><br></pre></td></tr></table></figure>





<h2 id="最后，重新来一遍浏览器缓存过程"><a href="#最后，重新来一遍浏览器缓存过程" class="headerlink" title="最后，重新来一遍浏览器缓存过程"></a>最后，重新来一遍浏览器缓存过程</h2><p><strong>第一次请求</strong></p>
<p>浏览器进行请求，发现缓存没有这个文件</p>
<p>向服务器进行请求，获得文件，并带上响应头：</p>
<p>​    属于强缓存的：Cache-Control，Expires</p>
<p>​    属于协商缓存的：ETag，Last-Modified</p>
<p>浏览器接收到了文件，并将文件和这些响应头缓存下来，下次使用。</p>
<p><strong>强缓存</strong></p>
<p>浏览器进行请求，发现缓存存在这个文件</p>
<p>浏览器缓存查看该次请求是否命中强缓存（就是没有超过文件缓存过期时间）</p>
<p>命中强缓存，直接从本地读取，状态码：200</p>
<p><strong>协商缓存</strong></p>
<p>浏览器进行请求，发现缓存存在这个文件</p>
<p>浏览器缓存查看该次请求是否命中强缓存，</p>
<p>没有命中强缓存，将 ETag 和 Last-Modified 的值放入请求头，</p>
<p>​    为 If-None-Match 和 If-Modified-Since，发送给服务器</p>
<p>服务器接收到请求后，查看是否命中协商缓存，</p>
<p>发现命中协商缓存，服务器会返回状态码 304，没有响应体</p>
<p>​    并将响应头的 Last-Modified 和 ETag 的值设置为文件的值，返回</p>
<p>客户端接收到服务器的 304 响应，并将 ETag 和 Last-Modified 存储下来。</p>
<p><strong>简单来说：</strong></p>
<p>​    就是第一次的文件请求会正常的返回，第二次会先看看能不能命中强缓存，如果能直接读取本地的，如果不能则看看能不能命中协商缓存，如果命中，则还是读取本地的文件，如果都没有命中，那么就会使用新的文件。</p>
<p>这里<strong>对于一个文件如何在强缓存期间进行更新</strong>也有说明：就是会对文件名进行hash计算，修改过的文件的hash值不一样，所以对于浏览器来说，这个文件名不一样，不是一个文件，需要重新请求。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallgy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
